{
  "hash": "e1f2b5f103f0b3f6e38d79b14b78c6de",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Selection of explanatory variables for yearly trend\"\nauthor: \"Niek Van Wettere\"\ndate: \"2025-12-15\"\ncategories: [trend analysis]\nformat: \n  html:\n    self-contained: true\n    toc: true\n    number-sections: true\n    code-fold: false\n    code-overflow: wrap\n    df-print: paged\neditor: source\n---\n\n<br />\n\n# Introduction\n\nThis blog post demonstrates a method to progressively select explanatory variables that present different trends from the overall yearly trend.\n\n<br />\n\n# Load packages\n\nWe use the data.table package, which allows for fast computation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(data.table, quietly = T)\n```\n:::\n\n\n<br />\n\n# Overview of functions\n\nNext, we create a series of R functions that will allow us to perform the variable analysis.\n\n<br />\n\n## Function to calculate percentage differences between consecutive years\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function to calculate percentage differences between consecutive years\ncalculate_percentage_differences <- function(dt, count_var, year_var, grouping_var) {\n  \n  # Ensure data is ordered by year\n  dt <- dt[order(get(year_var))]\n  \n  # If grouping_var is empty, don't group, just calculate the percentage difference for the entire dataset\n  if (length(grouping_var) > 0) {\n    dt[, perc_diff := ((.SD[[count_var]] - shift(.SD[[count_var]], type = \"lag\")) / shift(.SD[[count_var]], type = \"lag\")) * 100, by = grouping_var]\n  } else {\n    dt[, perc_diff := ((.SD[[count_var]] - shift(.SD[[count_var]], type = \"lag\")) / shift(.SD[[count_var]], type = \"lag\")) * 100]\n  }\n  \n  return(dt)\n}\n```\n:::\n\n\n<br />\n\n## Function to calculate deviation\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Helper function to calculate deviation\ncalculate_deviation <- function(actual, expected, metric) {\n  if (metric == \"mad\") return(mean(abs(actual - expected), na.rm = TRUE))\n  if (metric == \"mse\") return(mean((actual - expected)^2, na.rm = TRUE))\n  if (metric == \"rmse\") return(sqrt(mean((actual - expected)^2, na.rm = TRUE)))\n  if (is.function(metric)) return(metric(actual, expected)) # Allow user-defined metrics\n  stop(\"Unsupported deviation metric. Use 'mad', 'mse', 'rmse', or a custom function.\")\n}\n```\n:::\n\n\n<br />\n\n## Function to select variables with highest deviation from main trend\n\n\n::: {.cell}\n\n```{.r .cell-code}\nforward_selection_trends <- function(dt, included_vars, optional_vars, count_var = \"Count\", \n                                     year_var = \"Year\", agg_func = sum, min_row_threshold = 10, \n                                     stopping_threshold = 0.01, deviation_metric = \"mad\") {\n  # Ensure the data is a data.table\n  dt <- as.data.table(dt)\n  included_vars <- as.character(included_vars); selected_vars <- included_vars\n  optional_vars <- as.character(optional_vars); remaining_vars <- optional_vars\n  \n  # Check for missing data\n  if (anyNA(dt)) {\n    stop(\"The dataset contains missing values. Please clean or impute missing data before proceeding.\")\n  }\n  \n  selected_variables_and_deviations_at_each_step <- list() # To store selected variable and deviation at each step\n  iteration_details <- list() # To store details of all variables in each iteration\n  previous_deviation <- NA # Track deviation improvement\n  \n  start_time <- Sys.time()\n  cat(\"Starting forward selection with minimum row threshold =\", min_row_threshold, \"...\\n\")\n  \n  # Iterate until no remaining variable improves variability\n  for (step in seq_along(optional_vars)) {\n    \n    # Check if there are any remaining vars left. If not, exit.\n    if (length(remaining_vars) == 0) break\n    \n    # Calculate the reference percentage differences to be compared with\n    dt_ref_aggreg <- dt[, .(agg_count = agg_func(.SD[[count_var]])), by = c(year_var, selected_vars)]\n    ref_perc_diffs <- calculate_percentage_differences(copy(dt_ref_aggreg), count_var = 'agg_count', year_var, grouping_var = c(selected_vars))\n    \n    # Track deviations for all remaining variables\n    results <- lapply(remaining_vars, function(var) {\n      \n      # Aggregate the count variable using the custom function\n      grouped <- dt[, agg_count := agg_func(.SD[[count_var]]), by = c(selected_vars, var, year_var)]\n      \n      # Ensure enough rows exist in each group\n      if (min(grouped[, .N, by = c(selected_vars, var)]$N) < min_row_threshold) {\n        return(NA) # Skip variables that would result in too few rows in groups\n      }\n      \n      # Calculate percentage differences for each group\n      grouped_perc_diffs <- calculate_percentage_differences(copy(grouped), count_var = 'agg_count', year_var, grouping_var = c(selected_vars, var))\n      \n      \n      # Join with overall percentage differences to compare\n      comparison <- merge(grouped_perc_diffs, ref_perc_diffs, \n                          by = c(selected_vars, year_var), all.x = TRUE)\n      \n      \n      # Compute the deviation using the specified metric\n      calculate_deviation(comparison$perc_diff.x, comparison$perc_diff.y, deviation_metric)\n    })\n    \n    # Skip step if all remaining variables fail the row count threshold\n    if (all(is.na(results))) {\n      cat(\"Stopping: No variable meets the minimum row threshold.\\n\")\n      break\n    }\n    \n    # Capture deviations for all variables in the current iteration\n    iteration_deviation <- data.table(\n      Step = step,\n      Variable = remaining_vars,\n      Deviation = unlist(results)\n    )\n    iteration_details[[step]] <- iteration_deviation\n    \n    # Find the variable with the maximum deviation\n    deviations_step <- unlist(results)\n    max_deviation <- max(deviations_step, na.rm = TRUE)\n    max_var <- remaining_vars[which.max(deviations_step)]\n    \n    # Stop if the deviation improvement is below the threshold\n    if (!is.na(previous_deviation) && (max_deviation - previous_deviation) / abs(previous_deviation) < stopping_threshold) {\n      cat(\"Stopping: Deviation improvement below threshold.\\n\")\n      break\n    }\n    \n    previous_deviation <- max_deviation\n    \n    # Record the result\n    selected_variables_and_deviations_at_each_step[[step]] <- data.table(Step = step, Variable_with_max_deviation = max_var, Max_deviation = max_deviation)\n    \n    # Add the selected variable to included and remove from remaining\n    selected_vars <- c(selected_vars, max_var)\n    remaining_vars <- setdiff(remaining_vars, max_var)\n    \n    cat(\"Step\", step, \"- Variable selected:\", max_var, \"Deviation:\", max_deviation, \"\\n\")\n  }\n  \n  end_time <- Sys.time()\n  \n  # Final summary report\n  report <- list(\n    total_iterations = length(selected_variables_and_deviations_at_each_step),\n    selected_vars = selected_vars,\n    excluded_vars = setdiff(optional_vars, selected_vars),\n    execution_time = end_time - start_time,\n    deviation_metric = deviation_metric\n  )\n  \n  return(list(\n    selected_variables_and_deviations_at_each_step = rbindlist(selected_variables_and_deviations_at_each_step), # Final selection of variables with their deviations\n    iteration_details = rbindlist(iteration_details), # Details of all iterations\n    report = report # Summary report\n  ))\n}\n```\n:::\n\n\n<br />\n\n# Application\n\nFinally, we apply the function to test data.\n\n## Test data\n\nThe following code generates synthetic test data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(42)\n\n# Define dimensions\nyears <- 2000:2010\nregions <- c(\"North\", \"South\", \"East\", \"West\")\nproducts <- c(\"A\", \"B\")\nchannels <- c(\"Online\", \"Retail\")\n\n# Create base table with all combinations\ndt <- CJ(\n  Year = years,\n  Region = regions,\n  Product = products,\n  Channel = channels\n)\n\n# Base count\ndt[, base := 100]\n\n# Region-specific trends (strong signal)\nregion_trend <- c(\n  North = 0.06,\n  South = 0.03,\n  East  = 0.00,\n  West  = -0.02\n)\n\n# Product-specific trends (moderate signal)\nproduct_trend <- c(\n  A = 0.02,\n  B = 0.00\n)\n\n# Channel-specific noise (small)\nchannel_noise <- c(\n  Online = 0.005,\n  Retail = -0.005\n)\n\n# Generate counts: exponential growth + small noise\ndt[, Count :=\n     base *\n     exp(\n       region_trend[Region] * (Year - min(Year)) +\n         product_trend[Product] * (Year - min(Year)) +\n         channel_noise[Channel] * (Year - min(Year))\n     ) +\n     rnorm(.N, mean = 0, sd = 2)  # small random noise\n]\n\n# Ensure positive integer counts\ndt[, Count := pmax(round(Count), 1)]\n\n# Remove helper column\ndt[, base := NULL]\n\n# Check a few rows\nhead(dt)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"Year\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"Region\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"Product\"],\"name\":[3],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"Channel\"],\"name\":[4],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"Count\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"2000\",\"2\":\"East\",\"3\":\"A\",\"4\":\"Online\",\"5\":\"103\"},{\"1\":\"2000\",\"2\":\"East\",\"3\":\"A\",\"4\":\"Retail\",\"5\":\"99\"},{\"1\":\"2000\",\"2\":\"East\",\"3\":\"B\",\"4\":\"Online\",\"5\":\"101\"},{\"1\":\"2000\",\"2\":\"East\",\"3\":\"B\",\"4\":\"Retail\",\"5\":\"101\"},{\"1\":\"2000\",\"2\":\"North\",\"3\":\"A\",\"4\":\"Online\",\"5\":\"101\"},{\"1\":\"2000\",\"2\":\"North\",\"3\":\"A\",\"4\":\"Retail\",\"5\":\"100\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n<br />\n\n## Trend analysis\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# output res\n\nres <- forward_selection_trends(\n  dt,\n  included_vars = character(0),\n  optional_vars = c(\"Region\", \"Product\", \"Channel\"),\n  count_var = \"Count\",\n  year_var = \"Year\",\n  min_row_threshold = 10,\n  deviation_metric = \"mad\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nStarting forward selection with minimum row threshold = 10 ...\nStep 1 - Variable selected: Region Deviation: 3.146615 \nStopping: Deviation improvement below threshold.\n```\n\n\n:::\n:::\n\n\n<br />\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres[[1]]; res[[2]]; res[[3]]\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"Step\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"Variable_with_max_deviation\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"Max_deviation\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"Region\",\"3\":\"3.146615\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"Step\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"Variable\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"Deviation\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"Region\",\"3\":\"3.146615\"},{\"1\":\"1\",\"2\":\"Product\",\"3\":\"2.981233\"},{\"1\":\"1\",\"2\":\"Channel\",\"3\":\"2.902441\"},{\"1\":\"2\",\"2\":\"Product\",\"3\":\"2.342743\"},{\"1\":\"2\",\"2\":\"Channel\",\"3\":\"2.234737\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$total_iterations\n[1] 1\n\n$selected_vars\n[1] \"Region\"\n\n$excluded_vars\n[1] \"Product\" \"Channel\"\n\n$execution_time\nTime difference of 0.08608603 secs\n\n$deviation_metric\n[1] \"mad\"\n```\n\n\n:::\n:::\n\n\n\n<br />\n\n## Visualization\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n# Step 1: Compute aggregated counts by Year and Region\ndt_region <- dt[, .(agg_count = sum(Count)), by = .(Year, Region)]\n\ndt_region <- calculate_percentage_differences(dt_region, count_var = \"agg_count\", \n                                              year_var = \"Year\", grouping_var = c(\"Region\"))\n\n# Step 3: Plot percentage changes\n# Exclude the first year (where perc_diff is NA)\ndt_region_filtered <- dt_region[Year != min(Year)]\n\n# Then you can plot\nggplot(dt_region_filtered, aes(x = Year, y = perc_diff, color = Region)) +\n  geom_line(linewidth = 1.2) +\n  geom_point(size = 2) +\n  labs(title = \"Year-to-Year Percentage Changes by Region\",\n       y = \"Percentage Change (%)\",\n       x = \"Year\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](trend_explanatory_variables_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\n<br />\n\n\n",
    "supporting": [
      "trend_explanatory_variables_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}