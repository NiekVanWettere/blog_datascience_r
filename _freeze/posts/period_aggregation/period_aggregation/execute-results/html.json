{
  "hash": "c1584805be702cfeeb6123b29272aa9c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Aggregating overlapping time periods\"\nauthor: \"Niek Van Wettere\"\ndate: \"2025-11-19\"\ncategories: [data wrangling]\nimage: rivers_image.png\nformat: \n  html:\n    self-contained: true\n    toc: true\n    code-fold: false\n    code-overflow: wrap\n    df-print: paged\neditor: source\n---\n\nThis blog post shows a method to aggregate overlapping time periods in R. First, we generate dummy data that is structured as follows: for each event, several periods are defined with a start and end date. Some of these time periods overlap, while there are also gaps between periods that are not covered by the different periods for each event.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary('tidyverse', quietly = T)\n\ndf_with_periods <- tibble::tibble(\n  event = c(\n    rep(\"event1\", 4),\n    rep(\"event2\", 4),\n    rep(\"event3\", 4)\n  ),\n  start_date = as.Date(c(\n    \"2025-01-01\", \"2025-01-04\", \"2025-01-12\", \"2025-01-18\",   # event1\n    \"2025-01-03\", \"2025-01-05\", \"2025-01-14\", \"2025-01-20\",   # event2\n    \"2025-01-02\", \"2025-01-07\", \"2025-01-15\", \"2025-01-22\"    # event3\n  )),\n  end_date = as.Date(c(\n    \"2025-01-06\", \"2025-01-05\", \"2025-01-16\", \"2025-01-22\",   # event1\n    \"2025-01-07\", \"2025-01-12\", \"2025-01-18\", \"2025-01-25\",   # event2\n    \"2025-01-05\", \"2025-01-11\", \"2025-01-20\", \"2025-01-27\"    # event3\n  ))\n)\n\ndf_with_periods\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"event\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"start_date\"],\"name\":[2],\"type\":[\"date\"],\"align\":[\"right\"]},{\"label\":[\"end_date\"],\"name\":[3],\"type\":[\"date\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"event1\",\"2\":\"2025-01-01\",\"3\":\"2025-01-06\"},{\"1\":\"event1\",\"2\":\"2025-01-04\",\"3\":\"2025-01-05\"},{\"1\":\"event1\",\"2\":\"2025-01-12\",\"3\":\"2025-01-16\"},{\"1\":\"event1\",\"2\":\"2025-01-18\",\"3\":\"2025-01-22\"},{\"1\":\"event2\",\"2\":\"2025-01-03\",\"3\":\"2025-01-07\"},{\"1\":\"event2\",\"2\":\"2025-01-05\",\"3\":\"2025-01-12\"},{\"1\":\"event2\",\"2\":\"2025-01-14\",\"3\":\"2025-01-18\"},{\"1\":\"event2\",\"2\":\"2025-01-20\",\"3\":\"2025-01-25\"},{\"1\":\"event3\",\"2\":\"2025-01-02\",\"3\":\"2025-01-05\"},{\"1\":\"event3\",\"2\":\"2025-01-07\",\"3\":\"2025-01-11\"},{\"1\":\"event3\",\"2\":\"2025-01-15\",\"3\":\"2025-01-20\"},{\"1\":\"event3\",\"2\":\"2025-01-22\",\"3\":\"2025-01-27\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n<br />\n\nThe goal is now to merge overlapping periods into one longer period, while preserving the gaps between periods. To tackle this issue, we create several R functions.\n\nFirst, we define a function that, per event, orders the rows according to begin date and takes a rolling maximum of the end date. The start date of the next row is also added.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalculate_rolling_max_end_date <- function(data) {  # Order rows according to begin date and take rolling maximum of end date.\n  data |>\n    select(event, start_date, end_date) |>\n    distinct() |>\n    group_by(event) |>\n    arrange(start_date) |>\n    mutate(\n      end_date = as.Date(cummax(as.numeric(end_date)), origin = \"1970-01-01\"),\n      next_start_date = lead(start_date)) |> \n    ungroup()\n}\n\ndf_with_periods_aggregated <- df_with_periods |> calculate_rolling_max_end_date() |> arrange(event)\ndf_with_periods_aggregated\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"event\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"start_date\"],\"name\":[2],\"type\":[\"date\"],\"align\":[\"right\"]},{\"label\":[\"end_date\"],\"name\":[3],\"type\":[\"date\"],\"align\":[\"right\"]},{\"label\":[\"next_start_date\"],\"name\":[4],\"type\":[\"date\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"event1\",\"2\":\"2025-01-01\",\"3\":\"2025-01-06\",\"4\":\"2025-01-04\"},{\"1\":\"event1\",\"2\":\"2025-01-04\",\"3\":\"2025-01-06\",\"4\":\"2025-01-12\"},{\"1\":\"event1\",\"2\":\"2025-01-12\",\"3\":\"2025-01-16\",\"4\":\"2025-01-18\"},{\"1\":\"event1\",\"2\":\"2025-01-18\",\"3\":\"2025-01-22\",\"4\":\"<NA>\"},{\"1\":\"event2\",\"2\":\"2025-01-03\",\"3\":\"2025-01-07\",\"4\":\"2025-01-05\"},{\"1\":\"event2\",\"2\":\"2025-01-05\",\"3\":\"2025-01-12\",\"4\":\"2025-01-14\"},{\"1\":\"event2\",\"2\":\"2025-01-14\",\"3\":\"2025-01-18\",\"4\":\"2025-01-20\"},{\"1\":\"event2\",\"2\":\"2025-01-20\",\"3\":\"2025-01-25\",\"4\":\"<NA>\"},{\"1\":\"event3\",\"2\":\"2025-01-02\",\"3\":\"2025-01-05\",\"4\":\"2025-01-07\"},{\"1\":\"event3\",\"2\":\"2025-01-07\",\"3\":\"2025-01-11\",\"4\":\"2025-01-15\"},{\"1\":\"event3\",\"2\":\"2025-01-15\",\"3\":\"2025-01-20\",\"4\":\"2025-01-22\"},{\"1\":\"event3\",\"2\":\"2025-01-22\",\"3\":\"2025-01-27\",\"4\":\"<NA>\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\n<br />\n\nThen, we search for the rows where there is a time gap between the end date and the 'next start date'. This allows us to establish the time gaps, together with the oldest start date and the most recent end date. Since there are no complications of overlaps during the time gaps, it's easier to first detect these gaps and reason from there to get the 'unified' time periods.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nidentify_gaps <- function(data) {\n  gaps <- data |>   \n    filter(difftime(next_start_date, end_date, units = \"days\") > 1) |>  # Find the rows with gaps.\n    select(- start_date) |>\n    rename(start_date = next_start_date) |>\n    select(event, start_date, end_date)\n  \n  min_begin <- data |>\n    group_by(event) |>\n    summarise(start_date = min(start_date), .groups = 'drop') |>\n    mutate(end_date = NA)\n  \n  max_end <- data |>\n    group_by(event) |>\n    summarise(end_date = max(end_date), .groups = 'drop') |>\n    mutate(start_date = NA)\n  \n  gaps <- bind_rows(gaps, min_begin, max_end) \n  \n  return(gaps)\n}\n\ndf_with_periods_aggregated_2 <- df_with_periods_aggregated |> identify_gaps() |> arrange(event, start_date) \ndf_with_periods_aggregated_2 |> select(event, end_date, start_date)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"event\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"end_date\"],\"name\":[2],\"type\":[\"date\"],\"align\":[\"right\"]},{\"label\":[\"start_date\"],\"name\":[3],\"type\":[\"date\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"event1\",\"2\":\"<NA>\",\"3\":\"2025-01-01\"},{\"1\":\"event1\",\"2\":\"2025-01-06\",\"3\":\"2025-01-12\"},{\"1\":\"event1\",\"2\":\"2025-01-16\",\"3\":\"2025-01-18\"},{\"1\":\"event1\",\"2\":\"2025-01-22\",\"3\":\"<NA>\"},{\"1\":\"event2\",\"2\":\"<NA>\",\"3\":\"2025-01-03\"},{\"1\":\"event2\",\"2\":\"2025-01-12\",\"3\":\"2025-01-14\"},{\"1\":\"event2\",\"2\":\"2025-01-18\",\"3\":\"2025-01-20\"},{\"1\":\"event2\",\"2\":\"2025-01-25\",\"3\":\"<NA>\"},{\"1\":\"event3\",\"2\":\"<NA>\",\"3\":\"2025-01-02\"},{\"1\":\"event3\",\"2\":\"2025-01-05\",\"3\":\"2025-01-07\"},{\"1\":\"event3\",\"2\":\"2025-01-11\",\"3\":\"2025-01-15\"},{\"1\":\"event3\",\"2\":\"2025-01-20\",\"3\":\"2025-01-22\"},{\"1\":\"event3\",\"2\":\"2025-01-27\",\"3\":\"<NA>\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n<br />\n\nFinally, the aggregated intervals are calculated, based on the time gaps.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalculate_aggregated_intervals <- function(data) {\n  data |>\n    group_by(event) |>\n    arrange(start_date) |>\n    mutate(end_date = lead(end_date)) |>\n    ungroup() |>\n    filter(! is.na(start_date))\n}\n\ndf_with_periods_aggregated_3 <- df_with_periods_aggregated_2 |> calculate_aggregated_intervals() |> arrange(event)\ndf_with_periods_aggregated_3\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"event\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"start_date\"],\"name\":[2],\"type\":[\"date\"],\"align\":[\"right\"]},{\"label\":[\"end_date\"],\"name\":[3],\"type\":[\"date\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"event1\",\"2\":\"2025-01-01\",\"3\":\"2025-01-06\"},{\"1\":\"event1\",\"2\":\"2025-01-12\",\"3\":\"2025-01-16\"},{\"1\":\"event1\",\"2\":\"2025-01-18\",\"3\":\"2025-01-22\"},{\"1\":\"event2\",\"2\":\"2025-01-03\",\"3\":\"2025-01-12\"},{\"1\":\"event2\",\"2\":\"2025-01-14\",\"3\":\"2025-01-18\"},{\"1\":\"event2\",\"2\":\"2025-01-20\",\"3\":\"2025-01-25\"},{\"1\":\"event3\",\"2\":\"2025-01-02\",\"3\":\"2025-01-05\"},{\"1\":\"event3\",\"2\":\"2025-01-07\",\"3\":\"2025-01-11\"},{\"1\":\"event3\",\"2\":\"2025-01-15\",\"3\":\"2025-01-20\"},{\"1\":\"event3\",\"2\":\"2025-01-22\",\"3\":\"2025-01-27\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n<br />\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}