[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blog about data science in R",
    "section": "",
    "text": "Aggregating overlapping time periods\n\n\n\ndata wrangling\n\n\n\n\n\n\n\n\n\nNov 19, 2025\n\n\nNiek Van Wettere\n\n\n\n\n\n\n\n\n\n\n\n\nHistogram with median, interquartile range and outlier highlighting\n\n\n\nvisualization\n\n\n\n\n\n\n\n\n\nNov 2, 2025\n\n\nNiek Van Wettere\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/histogram/index.html",
    "href": "posts/histogram/index.html",
    "title": "Histogram with median, interquartile range and outlier highlighting",
    "section": "",
    "text": "In this blog post, we explore how a histogram plot can be enriched with information about median, interquartile range and outlier highlighting.\nFirst, we load the tidyverse package.\n\nlibrary('tidyverse', quietly = T)\n\n\nDummy data is generated: test scores for four different ‘education levels’.\n\nset.seed(123)\n\nn &lt;- 1000\nn_outliers &lt;- 20  # number of outliers\n\n# Generate test scores mostly around 50 with sd 15\ntest_scores &lt;- rnorm(n, mean = 50, sd = 15)\n\n# Clip values between 0 and 100\ntest_scores &lt;- pmin(pmax(test_scores, 0), 100)\n\n# Add some extreme outliers\noutlier_indices &lt;- sample(1:n, n_outliers)\ntest_scores[outlier_indices] &lt;- sample(c(runif(n_outliers/2, 90, 100),  # high outliers\n                                         runif(n_outliers/2, 0, 10)))   # low outliers\n\n# Create education levels\neducation_levels &lt;- sample(c(\"Level 1\", \"Level 2\", \"Level 3\", \"Level 4\"), n, replace = TRUE)\n\n# Combine into a dataframe\ndataframe_with_test_scores &lt;- data.frame(\n  test_scores = test_scores,\n  education_levels = education_levels\n)\n\n\nWe calculate median and IQR-limits to plot along the histogram.\n\nsummary_data_IQR &lt;- dataframe_with_test_scores |&gt;\n\n  group_by(education_levels) |&gt;\n\n  summarise(\n\n    number_of_students = n(),\n    median_test_score = median(test_scores),\n    IQR_lower = quantile(test_scores, 0.25),\n    IQR_upper = quantile(test_scores, 0.75), .groups = 'drop') |&gt;\n\n  mutate(IQR_range = (IQR_upper - IQR_lower) |&gt; round(2),\n\n         outlier_threshold_1 = IQR_upper + (IQR_range * 1.5),\n         outlier_threshold_2 = IQR_lower - (IQR_range * 1.5))\n\n\nThat information is joined with the original dataframe containing the test scores.\n\ntest_scores_per_education_level_list &lt;- dataframe_with_test_scores |&gt;\n  left_join(summary_data_IQR, by = join_by(education_levels))  |&gt;\n  group_split(education_levels) # Split in list of dataframes.\n\n\nWe create the histogram plots.\n\nThe median value is shown as a green vertical line.\nThe interquartile range is situated between the blue vertical lines.\nOutlier values are colored in red.\n\n\nlist_plots &lt;- vector(mode = \"list\", length = length(test_scores_per_education_level_list))\n\nfor (i in seq_along(test_scores_per_education_level_list))  { \n\n  # flexible bin-width\n  max_value &lt;- max(test_scores_per_education_level_list[[i]]$test_scores, na.rm = TRUE)\n  binwidth &lt;- max_value / 40 \n\n  # median IQR-range\n  median_coord &lt;- test_scores_per_education_level_list[[i]]$median_test_score[1]\n  median_label &lt;- paste0(test_scores_per_education_level_list[[i]]$median_test_score[1] |&gt; round(2), '%')\n  IQR_upper_x_coord &lt;- test_scores_per_education_level_list[[i]]$IQR_upper[1]\n  IQR_range_label &lt;- paste0('iqr: ', test_scores_per_education_level_list[[i]]$IQR_range[1], '%')\n\n  # plot histogram\nplot_result &lt;- test_scores_per_education_level_list[[i]] |&gt;\n  mutate(color = ifelse(test_scores &gt; outlier_threshold_1 | test_scores &lt; outlier_threshold_2, \"darkred\", \"grey\")) |&gt;\n\n \n  ggplot(aes(x = test_scores, fill = color)) +\n\n  facet_grid(cols = vars(education_levels), scales = 'fixed') +\n\n  scale_x_continuous(breaks = scales::pretty_breaks(), labels = scales::percent_format(scale = 1), expand = expansion(mult = c(0, 0.05))) +\n\n  scale_y_continuous(breaks = scales::pretty_breaks(), labels = scales::number_format(accuracy = 1)) +\n\n  geom_histogram(binwidth = binwidth) +\n\n  scale_fill_identity() +\n\ngeom_segment(aes(x = median_test_score, xend = median_test_score, y = 0, yend = Inf), color = \"darkgreen\", linewidth = 0.5, linetype = \"dashed\") +\n\n  geom_segment(aes(x = IQR_lower, xend = IQR_lower, y = 0, yend = Inf), color = \"blue\", linewidth = 0.5, linetype = \"dashed\") +\n\n  geom_segment(aes(x = IQR_upper, xend = IQR_upper, y = 0, yend = Inf), color = \"blue\", linewidth = 0.5, linetype = \"dashed\")  +\n\n  labs(x = \"test scores\", y = \"number of students\") +\n\n  theme_bw() +\n\n  theme(axis.title.x = element_text(size = 10),  # Adjust x-axis title size\n\n        axis.title.y = element_text(size = 10))   # Adjust y-axis title size\n\n\nmax_count_bin &lt;- max(ggplot_build(plot_result)$data[[1]]$count)\n\n# add text annotation for median and iqr-range\nplot_result_with_annotation &lt;- plot_result +\n\n  annotate(\"text\", x = IQR_upper_x_coord + (0.04 * max_value), y = 0.9 * max_count_bin, label = IQR_range_label, vjust = 1, hjust = 0, color = \"blue\", size = 3) +\n\nannotate(\"text\", x = median_coord, y = 0, label = median_label, vjust = 1.5, color = \"darkgreen\", size = 3) + expand_limits(y = - (max_count_bin * 0.1))\n\n\nlist_plots[[i]] &lt;- plot_result_with_annotation\n\n}\n\n\nNow we visualize one plot from the list of plots that was created.\n\nlist_plots[[1]]\n\n\n\n\n\n\n\n\n\nThe different graphs can also be combined in one panel.\n\nlayout_matrix &lt;- rbind(c(1, 2),\n\n                       c(3, 4))\n\ngridExtra::grid.arrange(grobs = list_plots, layout_matrix = layout_matrix, ncol = 2, top = \"Distribution of test scores per education level\")"
  },
  {
    "objectID": "posts/period_aggregation/index.html",
    "href": "posts/period_aggregation/index.html",
    "title": "Aggregating overlapping time periods",
    "section": "",
    "text": "This blog post shows a method to aggregate overlapping time periods in R. First, we generate dummy data that is structured as follows: for each event, several periods are defined with a start and end date. Some of these time periods overlap, while there are also gaps between periods that are not covered by the different periods for each event.\n\nlibrary('tidyverse', quietly = T)\n\ndf_with_periods &lt;- tibble::tibble(\n  event = c(\n    rep(\"event1\", 4),\n    rep(\"event2\", 4),\n    rep(\"event3\", 4)\n  ),\n  start_date = as.Date(c(\n    \"2025-01-01\", \"2025-01-04\", \"2025-01-12\", \"2025-01-18\",   # event1\n    \"2025-01-03\", \"2025-01-05\", \"2025-01-14\", \"2025-01-20\",   # event2\n    \"2025-01-02\", \"2025-01-07\", \"2025-01-15\", \"2025-01-22\"    # event3\n  )),\n  end_date = as.Date(c(\n    \"2025-01-06\", \"2025-01-05\", \"2025-01-16\", \"2025-01-22\",   # event1\n    \"2025-01-07\", \"2025-01-12\", \"2025-01-18\", \"2025-01-25\",   # event2\n    \"2025-01-05\", \"2025-01-11\", \"2025-01-20\", \"2025-01-27\"    # event3\n  ))\n)\n\ndf_with_periods\n\n\n  \n\n\n\n\nThe goal is now to merge overlapping periods into one longer period, while preserving the gaps between periods. To tackle this issue, we create several R functions.\nFirst, we define a function that, per event, orders the rows according to begin date and takes a rolling maximum of the end date. The start date of the next row is also added.\n\ncalculate_rolling_max_end_date &lt;- function(data) {  # Order rows according to begin date and take rolling maximum of end date.\n  data |&gt;\n    select(event, start_date, end_date) |&gt;\n    distinct() |&gt;\n    group_by(event) |&gt;\n    arrange(start_date) |&gt;\n    mutate(\n      end_date = as.Date(cummax(as.numeric(end_date)), origin = \"1970-01-01\"),\n      next_start_date = lead(start_date)) |&gt; \n    ungroup()\n}\n\ndf_with_periods_aggregated &lt;- df_with_periods |&gt; calculate_rolling_max_end_date() |&gt; arrange(event)\ndf_with_periods_aggregated\n\n\n  \n\n\n\n\nThen, we search for the rows where there is a time gap between the end date and the ‘next start date’. This allows us to establish the time gaps, together with the oldest start date and the most recent end date. Since there are no complications of overlaps during the time gaps, it’s easier to first detect these gaps and reason from there to get the ‘unified’ time periods.\n\nidentify_gaps &lt;- function(data) {\n  gaps &lt;- data |&gt;   \n    filter(difftime(next_start_date, end_date, units = \"days\") &gt; 1) |&gt;  # find the rows with gaps\n    select(- start_date) |&gt;\n    rename(start_date = next_start_date) |&gt;\n    select(event, start_date, end_date)\n  \n  min_begin &lt;- data |&gt;\n    group_by(event) |&gt;\n    summarise(start_date = min(start_date), .groups = 'drop') |&gt;\n    mutate(end_date = NA)\n  \n  max_end &lt;- data |&gt;\n    group_by(event) |&gt;\n    summarise(end_date = max(end_date), .groups = 'drop') |&gt;\n    mutate(start_date = NA)\n  \n  gaps &lt;- bind_rows(gaps, min_begin, max_end) \n  \n  return(gaps)\n}\n\ndf_with_periods_aggregated_2 &lt;- df_with_periods_aggregated |&gt; identify_gaps() |&gt; arrange(event, start_date) |&gt; select(event, end_date, start_date)\ndf_with_periods_aggregated_2\n\n\n  \n\n\n\n\nFinally, the aggregated intervals are calculated, based on the time gaps.\n\ncalculate_aggregated_intervals &lt;- function(data) {\n  data |&gt;\n    group_by(event) |&gt;\n    arrange(start_date) |&gt;\n    mutate(end_date = lead(end_date)) |&gt;\n    ungroup() |&gt;\n    filter(! is.na(start_date))\n}\n\ndf_with_periods_aggregated_3 &lt;- df_with_periods_aggregated_2 |&gt; calculate_aggregated_intervals() |&gt; arrange(event)\ndf_with_periods_aggregated_3"
  },
  {
    "objectID": "posts/period_aggregation/period_aggregation.html",
    "href": "posts/period_aggregation/period_aggregation.html",
    "title": "Aggregating overlapping time periods",
    "section": "",
    "text": "This blog post shows a method to aggregate overlapping time periods in R. First, we generate dummy data that is structured as follows: for each event, several periods are defined with a start and end date. Some of these time periods overlap, while there are also gaps between periods that are not covered by the different periods for each event.\n\nlibrary('tidyverse', quietly = T)\n\ndf_with_periods &lt;- tibble::tibble(\n  event = c(\n    rep(\"event1\", 4),\n    rep(\"event2\", 4),\n    rep(\"event3\", 4)\n  ),\n  start_date = as.Date(c(\n    \"2025-01-01\", \"2025-01-04\", \"2025-01-12\", \"2025-01-18\",   # event1\n    \"2025-01-03\", \"2025-01-05\", \"2025-01-14\", \"2025-01-20\",   # event2\n    \"2025-01-02\", \"2025-01-07\", \"2025-01-15\", \"2025-01-22\"    # event3\n  )),\n  end_date = as.Date(c(\n    \"2025-01-06\", \"2025-01-05\", \"2025-01-16\", \"2025-01-22\",   # event1\n    \"2025-01-07\", \"2025-01-12\", \"2025-01-18\", \"2025-01-25\",   # event2\n    \"2025-01-05\", \"2025-01-11\", \"2025-01-20\", \"2025-01-27\"    # event3\n  ))\n)\n\ndf_with_periods\n\n\n  \n\n\n\n\nThe goal is now to merge overlapping periods into one longer period, while preserving the gaps between periods. To tackle this issue, we create several R functions.\nFirst, we define a function that, per event, orders the rows according to begin date and takes a rolling maximum of the end date. The start date of the next row is also added.\n\ncalculate_rolling_max_end_date &lt;- function(data) {  # Order rows according to begin date and take rolling maximum of end date.\n  data |&gt;\n    select(event, start_date, end_date) |&gt;\n    distinct() |&gt;\n    group_by(event) |&gt;\n    arrange(start_date) |&gt;\n    mutate(\n      end_date = as.Date(cummax(as.numeric(end_date)), origin = \"1970-01-01\"),\n      next_start_date = lead(start_date)) |&gt; \n    ungroup()\n}\n\ndf_with_periods_aggregated &lt;- df_with_periods |&gt; calculate_rolling_max_end_date() |&gt; arrange(event)\ndf_with_periods_aggregated\n\n\n  \n\n\n\n\nThen, we search for the rows where there is a time gap between the end date and the ‘next start date’. This allows us to establish the time gaps, together with the oldest start date and the most recent end date. Since there are no complications of overlaps during the time gaps, it’s easier to first detect these gaps and reason from there to get the ‘unified’ time periods.\n\nidentify_gaps &lt;- function(data) {\n  gaps &lt;- data |&gt;   \n    filter(difftime(next_start_date, end_date, units = \"days\") &gt; 1) |&gt;  # Find the rows with gaps.\n    select(- start_date) |&gt;\n    rename(start_date = next_start_date) |&gt;\n    select(event, start_date, end_date)\n  \n  min_begin &lt;- data |&gt;\n    group_by(event) |&gt;\n    summarise(start_date = min(start_date), .groups = 'drop') |&gt;\n    mutate(end_date = NA)\n  \n  max_end &lt;- data |&gt;\n    group_by(event) |&gt;\n    summarise(end_date = max(end_date), .groups = 'drop') |&gt;\n    mutate(start_date = NA)\n  \n  gaps &lt;- bind_rows(gaps, min_begin, max_end) \n  \n  return(gaps)\n}\n\ndf_with_periods_aggregated_2 &lt;- df_with_periods_aggregated |&gt; identify_gaps() |&gt; arrange(event, start_date) \ndf_with_periods_aggregated_2 |&gt; select(event, end_date, start_date)\n\n\n  \n\n\n\n\nFinally, the aggregated intervals are calculated, based on the time gaps.\n\ncalculate_aggregated_intervals &lt;- function(data) {\n  data |&gt;\n    group_by(event) |&gt;\n    arrange(start_date) |&gt;\n    mutate(end_date = lead(end_date)) |&gt;\n    ungroup() |&gt;\n    filter(! is.na(start_date))\n}\n\ndf_with_periods_aggregated_3 &lt;- df_with_periods_aggregated_2 |&gt; calculate_aggregated_intervals() |&gt; arrange(event)\ndf_with_periods_aggregated_3"
  }
]